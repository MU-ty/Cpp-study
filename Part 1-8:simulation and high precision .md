恭喜大家完成了第一部分语言入门，相信大家已经可以使用 C++ 写出一些简单程序了。
各位读者有听说过“建模”一词吗？所谓“建模”，就是把事物进行抽象，根据实际问题来建立对应的数学模型。“抽象”并不意味着晦涩难懂；相反，它提供了大量的便利。计算机很难直接去解决实际问题，但是如果把实际问题建模成数学问题，就会大大地方便计算机来“理解”和“解决”。
举个生活中常见的例子：我们拿到了某次数学考试的成绩单，现在需要知道谁考得最好。当然不能把成绩单对着电脑晃一晃，然后问“谁考得最好？”。需要通过一种途径让计算机来理解这个问题。这个问题可以建模成：“给定数组 score[]，问数组内元素的最大值”。这样建模后，就能很方便的写程序解决问题了。对于这个问题，采用之前讨论过的“擂台法”，就可以给出答案。
如何把实际问题建模成数学问题，主要依靠我们的经验和直觉、当然还有你灵动的思维；而算法与数据结构，正是解决数学问题的两把利剑。从这一章开始会介绍一些程序设计竞赛中的一些常见套路算法，而下一部分会介绍基础的数据结构。如果已经认真学习完了第一部分，相信这一部分也不在话下。
这一章是语言部分的延伸，会介绍一些竞赛中会出现的“模拟题目”——这里的“模拟”不是指模拟某场比赛的模拟题，而是指让程序完整的按照题目叙述的方式执行运行得到最终答案。同时也会介绍可以计算很大整数的高精度运算方法。这一章对思维与算法设计的要求不高，但是会考验编程的基本功是否扎实。

# 8.1 乒乓球
## 题目背景
国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。
## 题目描述
华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。
比如现在有这么一份记录，（其中 $\texttt W$ 表示华华获得一分，$\texttt L$ 表示华华对手获得一分）：
$\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$
在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。
**注意：当一局比赛结束后，下一局立刻开始**。
你的程序就是要对于一系列比赛信息的输入（$\texttt{WL}$ 形式），输出正确的结果。
## 输入格式
每个输入文件包含若干行字符串，字符串由大写的 $\texttt W$ 、 $\texttt L$ 和 $\texttt E$ 组成。其中 $\texttt E$ 表示比赛信息结束，程序应该忽略 $\texttt E$ 之后的所有内容。
## 输出格式
输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是 $11$ 分制下的结果，第二部分是 $21$ 分制下的结果，两部分之间由一个空行分隔。
## 样例 #1
### 样例输入 #1
```
WWWWWWWWWWWWWWWWWWWW
WWLWE
```
### 样例输出 #1
```
11:0
11:0
1:1
  
21:0
2:1
```
## 提示
每行至多 $25$ 个字母，最多有 $2500$ 行。
（注：事实上有一个测试点有 $2501$ 行数据。）
```
#include<iostream>
#include<cmath>
using namespace std;

int f[2]={11,21};  // f[0]表示11分制，f[1]表示21分制
int a[25*2500+10],n=0;  // 用数组a存储每一分的结果，n记录比赛进行到哪一分

int main(){
    char tmp;  // 用来读取每个输入字符
    while(1){
        cin>>tmp;  // 输入一个字符
        if(tmp=='E') break;  // 输入'E'表示比赛结束，退出循环
        else if(tmp=='W')  a[n++]=1;  // 如果是'W'表示华华赢了一分，存储为1
        else if(tmp=='L')  a[n++]=0;  // 如果是'L'表示华华输了这一分，存储为0
    }

    for(int k=0;k<2;k++){  // 分别处理11分制和21分制
        int w=0,l=0;  // w表示华华得分，l表示对手得分
        for(int i=0;i<n;i++){  // 遍历所有比赛记录
            w+=a[i];  // 累加华华得分
            l+=1-a[i];  // 累加对手得分（1-a[i]的意思是，如果a[i]=1，表示对手得0分；如果a[i]=0，表示对手得1分）
            
            if((max(w,l)>=f[k])&&abs(w-l)>=2){  // 如果有一方得分达到目标（11或21），并且分差大于等于2
                cout<<w<<":"<<l<<endl;  // 输出当前局的比分
                w=l=0;  // 清空当前局的比分，开始新的一局
            }
        }
        cout<<w<<":"<<l<<endl;  // 输出比赛结束时的比分（有可能是最后一局还没结束）
        cout<<endl;  // 输出空行隔开两种规则的结果
    }
    return 0;
}
```
# 8.2 扫雷游戏
## 题目背景
NOIP2015 普及组 T2
## 题目描述
扫雷游戏是一款十分经典的单机小游戏。在 $n$ 行 $m$ 列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。
现在给出 $n$ 行 $m$ 列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。
注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。
## 输入格式
第一行是用一个空格隔开的两个整数 $n$ 和 $m$，分别表示雷区的行数和列数。
接下来 $n$ 行，每行 $m$ 个字符，描述了雷区中的地雷分布情况。字符 $\texttt{*}$ 表示相应格子是地雷格，字符 $\texttt{?}$ 表示相应格子是非地雷格。相邻字符之间无分隔符。
## 输出格式
输出文件包含 $n$ 行，每行 $m$ 个字符，描述整个雷区。用 $\texttt{*}$ 表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。
## 样例 #1
### 样例输入 #1
```
3 3
*??
???
?*?
```
### 样例输出 #1
```
*10
221
1*1
```
## 样例 #2
### 样例输入 #2
```
2 3
?*?
*??
```
### 样例输出 #2
```
2*1
*21
```
## 提示
对于 $100\%$的数据，$1≤n≤100, 1≤m≤100$。
```
#include<iostream>
using namespace std;
const int dx[]={1,1,1,0,0,-1,-1,-1};
const int dy[]={-1,0,1,-1,1,-1,0,1};
const int maxn=105;
char g[maxn][maxn];
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>g[i][j];
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(g[i][j]!='*'){
                int cnt=0;
                for(int k=0;k<8;k++){
                    if(g[i+dx[k]][j+dy[k]]=='*')
                    cnt++;
                }
                cout<<cnt;
            }else{
                cout<<'*';
            }
        }
    cout<<endl;
    }
    return 0;
}
```
# 8.3 玩具谜题

## 题目背景

NOIP2016 提高组 D1T1

## 题目描述

小南有一套可爱的玩具小人，它们各有不同的职业。

有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/0u7em9pi.png) 

这时 singer 告诉小南一个谜题：“眼镜藏在我左数第 $3$ 个玩具小人的右数第 $1$ 个玩具小人的左数第 $2$ 个玩具小人那里。”

小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。

小南一边艰难地辨认着玩具小人，一边数着:

singer 朝内，左数第 $3$ 个是 archer。

archer 朝外，右数第 $1$ 个是 thinker。

thinker 朝外，左数第 $2$ 个是 writer。

所以眼镜藏在 writer 这里！

虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜題具体可以描述为：

有 $n$ 个玩具小人围成一圈，已知它们的职业和朝向。现在第 $1$ 个玩具小人告诉小南一个包含 $m$ 条指令的谜題，其中第 $z$ 条指令形如“向左数/右数第 $s$ 个玩具小人”。你需要输出依次数完这些指令后，到达的玩具小人的职业。

## 输入格式

输入的第一行包含两个正整数 $n,m$，表示玩具小人的个数和指令的条数。

接下来 $n$ 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 $0$ 表示朝向圈内，$1$ 表示朝向圈外。保证不会出现其他的数。字符串长度不超过 $10$ 且仅由英文字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。

接下来 $m$ 行，其中第 $i$ 行包含两个整数 $a_i,s_i$，表示第 $i$ 条指令。若 $a_i=0$，表示向左数 $s_i$ 个人；若 $a_i=1$，表示向右数 $s_i$ 个人。 保证 $a_i$ 不会出现其他的数，$1 \le s_i < n$。

## 输出格式

输出一个字符串，表示从第一个读入的小人开始，依次数完 $m$ 条指令后到达的小人的职业。

## 样例 #1

### 样例输入 #1

```
7 3
0 singer
0 reader
0 mengbier 
1 thinker
1 archer
0 writer
1 mogician 
0 3
1 1
0 2
```

### 样例输出 #1

```
writer
```

## 样例 #2

### 样例输入 #2

```
10 10
1 C
0 r
0 P
1 d
1 e
1 m
1 t
1 y
1 u
0 V
1 7
1 1
1 4
0 5
0 3
0 1
1 6
1 2
0 8
0 4
```

### 样例输出 #2

```
y
```

## 提示

**样例 1 说明**

这组数据就是【题目描述】中提到的例子。


**子任务**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:
![7su06u3r](https://github.com/user-attachments/assets/0cda961e-e1d0-4692-b5a5-f88057df9dc1)

其中一些简写的列意义如下:

- 全朝内：若为 $\surd$，表示该测试点保证所有的玩具小人都朝向圈内；

- 全左数：若为 $\surd$，表示该测试点保证所有的指令都向左数，即对任意的 $1\leq z\leq m, a_i=0$；

- $s=1$：若为 $\surd$，表示该测试点保证所有的指令都只数 $1$ 个，即对任意的 $1\leq z\leq m,s_i=1$；

职业长度为 $1$：若为 $\surd$，表示该测试点保证所有玩具小人的职业一定是一个长度为 $1$ 的字符串。

```
#include<iostream>
#include<string>
using namespace std;
const int MAXN =1e6+5;
struct node{
    int head;
    string name;
}a[MAXN];
int n,m,x,y;
int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        cin>>a[i].head>>a[i].name;
    }
    int now=0;
    for(int i=1;i<=m;i++){
        cin>>x>>y;
    if(a[now].head==0&&x==0)  now=(now+n-y)%n;
    else if(a[now].head==0&&x==1)   now=(now+y)%n;
    else if(a[now].head==1&&x==0)   now=(now+y)%n;
    else if(a[now].head==1&&x==1)   now=(now+n-y)%n;
    }
    cout<<a[now].name<<endl;
    return 0;
}
```


# 8.4  A+B Problem（高精）
## 题目描述
高精度加法，相当于 a+b problem，**不用考虑负数**。
## 输入格式
分两行输入。$a,b \leq 10^{500}$。
## 输出格式
输出只有一行，代表 $a+b$ 的值。
## 样例 #1
### 样例输入 #1
```
1
1
```
### 样例输出 #1
```
2
```
## 样例 #2
### 样例输入 #2
```
1001
9099
```
### 样例输出 #2
```
10100
```
## 提示
$20\%$ 的测试数据，$0\le a,b \le10^9$；
$40\%$ 的测试数据，$0\le a,b \le10^{18}$。

```
#include<iostream>
#include<string>
#include<algorithm>
#define maxn 520
using namespace std;
int a[maxn],b[maxn],c[maxn];
int main(){
    string A,B;
    cin>>A>>B;
    int len=max(A.length(),B.length());
    for(int i=A.length()-1,j=1;i>=0;i--,j++)
        a[j]=A[i]-'0';
    for(int i=B.length()-1,j=1;i>=0;i--,j++)
        b[j]=B[i]-'0';
    for(int i=1;i<=len;i++){
        c[i]+=a[i]+b[i];
        c[i+1]=c[i]/10;
        c[i]%=10;
    }
    if(c[len+1])   len++;
    for(int i=len;i>=1;i--)   cout<<c[i];
}
```

# 8.5  A*B Problem
## 题目背景
高精度乘法模板题。
## 题目描述
给出两个非负整数，求它们的乘积。
## 输入格式
输入共两行，每行一个非负整数。
## 输出格式
输出一个非负整数表示乘积。
## 样例 #1
### 样例输入 #1
```
1 
2
```
### 样例输出 #1
```
2
```
## 提示
每个非负整数不超过 $10^{2000}$。

```
#include<iostream>
#include<string>
#define maxn 5010
using namespace std;

int a[maxn],b[maxn],c[maxn];
int main(){
    string A,B;
    cin>>A>>B;
    int lena=A.length(),lenb=B.length();
    for(int i=lena-1;i>=0;i--)  a[lena-i]=A[i]-'0';
    for(int i=lenb-1;i>=0;i--)  b[lenb-i]=B[i]-'0';
    for(int i=1;i<=lena;i++)
        for(int j=1;j<=lenb;j++)
            c[i+j-1]+=a[i]*b[j];
    int len=lena+lenb;
    for(int i=1;i<=len;i++){
        c[i+1]+=c[i]/10;
        c[i]%=10;
    }
    
    for(;!c[len];)
        len--;
    for(int i=max(1,len);i>=1;i--)
        cout<<c[i];
}
```

# 8.6 阶乘之和
## 题目描述
用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。
其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。
## 输入格式
一个正整数 $n$。
## 输出格式
一个正整数 $S$，表示计算结果。
## 样例 #1
### 样例输入 #1
```
3
```
### 样例输出 #1
```
9
```
## 提示
**【数据范围】**
对于 $100 \%$ 的数据，$1 \le n \le 50$。
**【其他说明】**
注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。
如果希望通过本题，请继续学习第八章高精度的知识。
### 标准答案
```cpp
#include<iostream>
#include <cstring> // for memset
#include <algorithm> // for std::max
#define maxn 100
using namespace std;

struct Bigint{
    int len, a[maxn];
    Bigint(int x = 0) {
        memset(a, 0, sizeof(a));
        for (len = 1; x; len++)
            a[len] = x % 10, x /= 10;
        len--;
    }
    int& operator[](int i) {
        return a[i];
    }
    void flatten(int L) {
        len = L;
        for (int i = 1; i <= len; i++)
            a[i + 1] += a[i] / 10, a[i] %= 10;
        for (; !a[len];)
            len--;
    }
    void print() {
        for (int i = len; i >= 1; i--)
            printf("%d", a[i]);
    }
};

Bigint operator+(Bigint a, Bigint b) {
    Bigint c;
    int len = max(a.len, b.len);
    for (int i = 1; i <= len; i++) {
        c[i] += a[i] + b[i];
    }
    c.flatten(len + 1);
    return c;
}

Bigint operator*(Bigint a, int b) {
    Bigint c;
    int len = a.len;
    for (int i = 1; i <= len; i++)
        c[i] = a[i] * b;
    c.flatten(len + 11);
    return c;
}

int main() {
    Bigint ans(0), fac(1);
    int m;
    cin >> m;
    for (int i = 1; i <= m; i++) {
        fac = fac * i;
        ans =ans+ fac;
    }
    ans.print();
}
```

### 其他答案
```cpp
#include<stdio.h>
#define MAX 66 //50的阶乘为65位，B存的是每一个数的阶乘
//一位数+一位数不会超过两位数 如9+9=18，两位数加两位数不会超过3位数。即相加和最大位数取决于加数的最大位数+1
//所以由此可得，1！+2！位数不会超过2！的位数，依次类推下去。
//阶乘和的最大位数取决于最大阶乘位数+1 此处即50！ 的位数+1。当然，小数据阶乘和的位数不算多，这样精算其实节省不了什么时间，可尽量将数组开大点。
int main()
{
    int i, A[MAX+1] = { 0 }, B[MAX+1] = { 0 }, n, j;
    scanf("%d", &n);
    A[0] = B[0] = 1;//反正都是从1开始，A是用来存阶乘之和，B是用来存每次的i的阶乘 
    for (i = 2; i <= n; i++) {
        for (j = 0; j < MAX; j++)
            B[j] *= i;//利用 n！=n*（n-1）！，B用来存每一次i的阶乘 ,B的每一位都要和i相乘 模拟乘法 
        for (j = 0; j < MAX; j++)//模拟进位
            if (B[j] > 9) {
                B[j + 1] += B[j] / 10;
                B[j] %= 10;
            }
        for (j = 0; j < MAX; j++) {//A来存每次的阶乘相加  高精度加法 
            A[j] += B[j];
            if (A[j] > 9) {
                A[j + 1] += A[j] / 10;
                A[j] %= 10;
            }
        }
    }
    for (i = MAX; i >= 0 && A[i] == 0; i--);//去除前导0 
    for (j = i; j >= 0; j--) printf("%d", A[j]);
    return 0;
}
```
