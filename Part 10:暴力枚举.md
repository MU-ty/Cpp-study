设想一下，你觉得家门口的山非常碍事，下决心发扬“愚公移山”精神，凭借一镐一担打算把山一点一点的移走。虽然精神值得褒奖，而且理论上是可行的，只要给予足够多的时间迟早能做到。但是，实际上并不可能给你那么多时间，所以使用这种办法在有生之年是不可能将山移开的（也许你可以使用更好的办法，比如使用魔法或者设法让天神感动，让他帮你移山）。然而，如果你只是把一个不到半人高的小沙堆给移走，那使用这种方法很快就可以完成了。
算法的世界高深莫测，但是很多问题的解决方法简单而粗暴——就是枚举出所有可能的情况，然后判断或者统计，从而解决问题。在很多程序设计比赛中，有许多比较简单的题目是可以通过枚举暴力解决的；而有的更有具有挑战性的题目虽然有更巧妙的解法，但依然可以使用枚举暴力完成部分任务。
本章将介绍一些枚举与暴力策略，这是非常基础而且重要的，但是对初学者来说还是会有一些挑战。请务必理解本章之前的所有章节后再开始本章的学习。
## 一、 循环枚举
# 10.1 统计方形（数据加强版）
## 题目描述
有一个 $n \times m$ 方格的棋盘，求其方格包含多少正方形、长方形（不包含正方形）。
## 输入格式
一行，两个正整数 $n,m$（$n \leq 5000,m \leq 5000$）。
## 输出格式
一行，两个正整数，分别表示方格包含多少正方形、长方形（不包含正方形）。
## 样例 #1
### 样例输入 #1
```
2 3
```
### 样例输出 #1
```
8 10
```
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long LL;
int main() {
    LL n, m, squ = 0, rec = 0;
    scanf("%lld%lld", &n, &m);
    for (LL x = 0; x <= n; x++) {
        for (LL y = 0; y <= m; y++) {
            LL tmp = min(x, y) + min(y, n - x) + min(n - x, m - y) + min(m - y, x);
            squ += tmp;
            rec += n * m - tmp;
        }
    }
    printf("%lld %lld", squ / 4, rec / 4);
}
```
我们来详细讲解**矩形总数的计算方法**。
---
### **核心思想**
在一个 \( n \times m \) 的棋盘中，每一个矩形可以由两条水平线和两条垂直线框住：
1. 水平线有 \( n+1 \) 条（包括上下边界）。
2. 垂直线有 \( m+1 \) 条（包括左右边界）。
- **选择水平线的方法**：从 \( n+1 \) 条水平线中任意选择 2 条，表示矩形的上下边界。  
  选择的组合数为：
  \[
  C(n+1, 2) = \frac{(n+1) \cdot n}{2}
  \]
- **选择垂直线的方法**：从 \( m+1 \) 条垂直线中任意选择 2 条，表示矩形的左右边界。  
  选择的组合数为：
  \[
  C(m+1, 2) = \frac{(m+1) \cdot m}{2}
  \]
因此，矩形总数为两种选择数的乘积：
\[
\text{矩形总数} = C(n+1, 2) \cdot C(m+1, 2) = \frac{n(n+1)}{2} \cdot \frac{m(m+1)}{2}
\]
---
### **公式**
矩形总数可以直接计算为：
\[
\text{矩形总数} = \left( \frac{n(n+1)}{2} \right) \times \left( \frac{m(m+1)}{2} \right)
\]
---
### **举例**
#### 示例 1：\( 2 \times 3 \) 棋盘
1. 水平线有 \( 2+1 = 3 \) 条。
2. 垂直线有 \( 3+1 = 4 \) 条。
- 水平线的选择数：
  \[
  C(3, 2) = \frac{3 \cdot 2}{2} = 3
  \]
- 垂直线的选择数：
  \[
  C(4, 2) = \frac{4 \cdot 3}{2} = 6
  \]
矩形总数：
\[
\text{矩形总数} = 3 \times 6 = 18
\]
---
#### 示例 2：\( 3 \times 3 \) 棋盘
1. 水平线有 \( 3+1 = 4 \) 条。
2. 垂直线有 \( 3+1 = 4 \) 条。

- 水平线的选择数：
  \[
  C(4, 2) = \frac{4 \cdot 3}{2} = 6
  \]

- 垂直线的选择数：
  \[
  C(4, 2) = \frac{4 \cdot 3}{2} = 6
  \]

矩形总数：
\[
\text{矩形总数} = 6 \times 6 = 36
\]
---
### **代码实现**
以下是矩形总数计算的代码实现：
#### C++
```cpp
#include <iostream>
using namespace std;

long long calculate_total_rectangles(int n, int m) {
    return (long long)n * (n + 1) / 2 * (long long)m * (m + 1) / 2;
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << calculate_total_rectangles(n, m) << endl; // 输出: 18
    return 0;
}
```
---
### **总结**
- 矩形总数的计算关键在于理解 “从 \( n+1 \) 条水平线中选择 2 条” 和 “从 \( m+1 \) 条垂直线中选择 2 条”。
- 通过公式直接计算，时间复杂度为 \( O(1) \)。

### **正方形总数的计算**
正方形是一种特殊的矩形，边长相等。计算正方形总数的方法是逐步统计不同边长的正方形数量。
---
### **思路**
1. **边长为 \( k \) 的正方形**：
   - 要构成一个边长为 \( k \) 的正方形，其左上角的位置范围为：
     - 行：\( 1 \) 到 \( n-k+1 \)
     - 列：\( 1 \) 到 \( m-k+1 \)
   - 因此，边长为 \( k \) 的正方形数量为：
     \[
     \text{数量} = (n-k+1) \times (m-k+1)
     \]
2. **累加所有可能边长的正方形**：
   - 边长可以从 \( 1 \) 到 \( \min(n, m) \)。
   - 总正方形数为：
     \[
     \text{正方形总数} = \sum_{k=1}^{\min(n, m)} (n-k+1) \times (m-k+1)
     \]
---
### **公式**
正方形总数：
\[
\text{正方形总数} = \sum_{k=1}^{\min(n, m)} (n-k+1) \times (m-k+1)
\]
---
### **举例**
#### 示例 1：\( 2 \times 3 \) 的棋盘
1. **边长为 1 的正方形**：
   - 左上角的行范围：\( 1 \) 到 \( 2 \)。
   - 左上角的列范围：\( 1 \) 到 \( 3 \)。
   - 数量：\( 2 \times 3 = 6 \)。
2. **边长为 2 的正方形**：
   - 左上角的行范围：\( 1 \) 到 \( 1 \)。
   - 左上角的列范围：\( 1 \) 到 \( 2 \)。
   - 数量：\( 1 \times 2 = 2 \)。
3. **总正方形数**：
   \[
   \text{正方形总数} = 6 + 2 = 8
   \]

---
#### 示例 2：\( 3 \times 3 \) 的棋盘
1. **边长为 1 的正方形**：
   - 左上角的行范围：\( 1 \) 到 \( 3 \)。
   - 左上角的列范围：\( 1 \) 到 \( 3 \)。
   - 数量：\( 3 \times 3 = 9 \)。
2. **边长为 2 的正方形**：
   - 左上角的行范围：\( 1 \) 到 \( 2 \)。
   - 左上角的列范围：\( 1 \) 到 \( 2 \)。
   - 数量：\( 2 \times 2 = 4 \)。
3. **边长为 3 的正方形**：
   - 左上角的行范围：\( 1 \) 到 \( 1 \)。
   - 左上角的列范围：\( 1 \) 到 \( 1 \)。
   - 数量：\( 1 \times 1 = 1 \)。
4. **总正方形数**：
   \[
   \text{正方形总数} = 9 + 4 + 1 = 14
   \]
---
### **代码实现**
#### Python实现
#### C++实现
```cpp
#include <iostream>
using namespace std;

long long calculate_total_squares(int n, int m) {
    long long total_squares = 0;
    for (int k = 1; k <= min(n, m); ++k) {
        total_squares += (long long)(n - k + 1) * (m - k + 1);
    }
    return total_squares;
}

int main() {
    int n, m;
    cin >> n >> m;
    cout << calculate_total_squares(n, m) << endl;  // 输出: 8
    return 0;
}
```
---
### **总结**
1. **正方形的核心计算逻辑**：每个边长 \( k \) 的正方形数量为 \( (n-k+1) \times (m-k+1) \)，逐步累加即可。
2. **时间复杂度**：由于边长 \( k \) 最多遍历到 \( \min(n, m) \)，时间复杂度为 \( O(\min(n, m)) \)。
3. **优势**：对于 \( n, m \leq 5000 \) 的大棋盘，计算速度非常快。

# 10.2 烤鸡
## 题目背景
猪猪Hanke 得到了一只鸡。
## 题目描述
猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。
现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。
## 输入格式
一个正整数 $n$，表示美味程度。
## 输出格式
第一行，方案总数。
第二行至结束，$10$ 个数，表示每种配料所放的质量，按字典序排列。
如果没有符合要求的方法，就只要在第一行输出一个 $0$。
## 样例 #1
### 样例输入 #1
```
11
```
### 样例输出 #1
```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1
```
## 提示
对于 $100\%$ 的数据，$n \leq 5000$。

```cpp
#include<cstdio>
using namespace std;
#define rep(i,a,b) for(int i=a;i<=b;i++)
int main(){
    int n,ans=0,cnt=10;
    scanf("%d",&n);
    rep(a,1,3) rep(b,1,3) rep(c,1,3) rep(d,1,3) rep(e,1,3)
      rep(f,1,3) rep(g,1,3) rep(h,1,3) rep(i,1,3) rep(j,1,3)
        if(a+b+c+d+e+f+g+h+i+j==n){
            ans++;
        }
    printf("%d\n",ans);
    rep(a,1,3) rep(b,1,3) rep(c,1,3) rep(d,1,3) rep(e,1,3)
      rep(f,1,3) rep(g,1,3) rep(h,1,3) rep(i,1,3) rep(j,1,3)
        if(a+b+c+d+e+f+g+h+i+j==n){
            printf("%d %d %d %d %d %d %d %d %d %d\n",a,b,c,d,e,f,g,h,i,j);
        }
    return 0;
}
```

# 10.3三连击（升级版）
## 题目描述
将 $1, 2,\ldots, 9$ 共 $9$ 个数分成三组，分别组成三个三位数，且使这三个三位数的比例是 $A:B:C$，试求出所有满足条件的三个三位数，若无解，输出 `No!!!`。
//感谢黄小U饮品完善题意
## 输入格式
三个数，$A,B,C$。
## 输出格式
若干行，每行 $3$ 个数字。按照每行第一个数字升序排列。
## 样例 #1
### 样例输入 #1
```
1 2 3
```
### 样例输出 #1
```
192 384 576
219 438 657
273 546 819
327 654 981
```
## 提示
保证 $A<B<C$。
---
$\text{upd 2022.8.3}$：新增加二组 Hack 数据。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int b[10];
void go(int x) {
	b[x % 10] = 1;
	b[x / 10 % 10] = 1;
	b[x / 100] = 1;
}
bool check(int x, int y, int z) {
	memset(b, 0, sizeof(b));
	if (y > 999 || z > 999) return 0;
	go(x), go(y), go(z);
	for (int i = 1; i <= 9; i++) {
		if (!b[i])  return 0;
	}
	return 1;
}
int main() {
	long long A, B, C, x, y, z, cnt = 0;
	cin >> A >> B >> C;
	for (x = 123; x <= 987; x++) {
		if (x * B % A || x * C % A)  continue;
		y = x * B / A, z = x * C / A;
		if (check(x, y, z))
			printf("%lld %lld %lld\n", x, y, z), cnt++;
	}
	if (!cnt)  puts("No!!!");
	return 0;
}
```
