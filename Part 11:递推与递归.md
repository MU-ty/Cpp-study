有些目标是宏大的，比如要在 IOI 赛场中得到满分（俗称 AK IOI）。如果你现在还是一个普通的学生，那么想达成这个目标太难了。但把这样宏大的目标分解为很多个子任务，就没觉得那么复杂了。
要想 AK IOI，只需要入选国家队，参加 IOI 即可。那怎么成为入选国家队呢？参加中国队选拔赛并通过面试答辩即可。使用同样的思路往前倒推，直到最后只剩下最基础的任务（比如认真的读完这章内容并完成练习），做完这样的小任务就很简单了。
像这样将一个很大的任务分解成规模小一些的子任务，子任务分成更小的子任务，直到遇到初始条件，最后整理归纳解决大任务的思想就是递推与递归思想，不过这两者还是有一些区别。
这一章涉及的内容是动态规划思想与分治策略的基础，大家也要认真学习啦，说不定目标就真的达到了。

## 一、递推思想
# 11.1数楼梯
## 题目描述
楼梯有 $N$ 阶，上楼可以一步上一阶，也可以一步上二阶。
编一个程序，计算共有多少种不同的走法。
## 输入格式
一个数字，楼梯数。
## 输出格式
输出走的方式总数。
## 样例 #1
### 样例输入 #1
```
4
```
### 样例输出 #1
```
5
```
## 提示
- 对于 $60\%$ 的数据，$N \leq 50$；   
- 对于 $100\%$ 的数据，$1 \le N \leq 5000$。

```cpp

```

# 11.2 过河卒
## 题目描述
棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。
棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。
![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)
现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。
## 输入格式
一行四个正整数，分别表示 $B$ 点坐标和马的坐标。
## 输出格式
一个整数，表示所有的路径条数。
## 样例 #1
### 样例输入 #1
```
6 6 3 3
```
### 样例输出 #1
```
6
```
## 提示
对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

```cpp
#include<iostream>
#define maxn 22
using namespace std;
long long f[maxn][maxn]={0};
int ctr1[maxn][maxn],n,m,hx,hy;
int d[9][2]={{0,0},{1,2},{1,-2},{-1,2},{-1,-2},
    {2,1},{2,-1},{-2,1},{-2,-1}};
int main(){
    cin>>n>>m>>hx>>hy;
    for(int i=0;i<9;i++){
        int tmpx=hx+d[i][0],tmpy=hy+d[i][1];
        if(tmpx>=0&&tmpx<=n&&tmpy>=0&&tmpy<=m)
            ctr1[tmpx][tmpy]=1;
    }
    
    f[0][0]=1-ctr1[0][0];
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++){
            if(ctr1[i][j])   continue;
            if(i!=0) f[i][j]+=f[i-1][j];
            if(j!=0) f[i][j]+=f[i][j-1];
        }
    cout<<f[n][m];
    return 0;
}
```

## 代码解读
这段代码实现了“过河卒”问题，主要是通过动态规划的方法计算从起点 \( (0, 0) \) 到终点 \( (n, m) \) 的路径总数，同时考虑了“马的控制点”对路径的阻碍。
---
### **代码功能分解**
#### **1. 定义与初始化**
```cpp
#define maxn 22
long long f[maxn][maxn] = {0};
int ctr1[maxn][maxn], n, m, hx, hy;
int d[9][2] = {{0, 0}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}, {2, 1}, {2, -1}, {-2, 1}, {-2, -1}};
```
- `f[maxn][maxn]`：用来存储从起点 \( (0, 0) \) 到棋盘某个位置 \( (i, j) \) 的路径总数。
- `ctr1[maxn][maxn]`：标记棋盘上哪些点是被马控制的，1 表示被控制，0 表示未被控制。
- `n, m`：目标点 \( (n, m) \) 的坐标。
- `hx, hy`：马的位置坐标 \( (hx, hy) \)。
- `d[9][2]`：表示马能够控制的 9 个点的坐标偏移量，包括马自己所在的位置。

---
#### **2. 计算马的控制范围**
```cpp
for (int i = 0; i < 9; i++) {
    int tmpx = hx + d[i][0], tmpy = hy + d[i][1];
    if (tmpx >= 0 && tmpx <= n && tmpy >= 0 && tmpy <= m)
        ctr1[tmpx][tmpy] = 1;
}
```
- 马可以控制 8 个方向的点以及其当前位置。
- 通过 `d[i][0]` 和 `d[i][1]` 对 \( (hx, hy) \) 进行偏移，计算出马能够控制的所有点。
- 如果偏移后的点 \( (tmpx, tmpy) \) 在棋盘范围内 \( (0 \leq tmpx \leq n, 0 \leq tmpy \leq m) \)，就将 `ctr1[tmpx][tmpy]` 标记为 1。
---
#### **3. 初始化起点的路径数**
```cpp
f[0][0] = 1 - ctr1[0][0];
```
- 如果起点 \( (0, 0) \) 没有被马控制，则路径数为 1；如果被马控制，路径数为 0。

---
#### **4. 动态规划转移方程**
```cpp
for (int i = 0; i <= n; i++)
    for (int j = 0; j <= m; j++) {
        if (ctr1[i][j]) continue; // 被马控制的点跳过
        if (i != 0) f[i][j] += f[i-1][j]; // 从上方到达
        if (j != 0) f[i][j] += f[i][j-1]; // 从左方到达
    }
```
- 遍历棋盘的每个点 \( (i, j) \)，计算路径总数：
  - 如果当前点 \( (i, j) \) 被马控制（`ctr1[i][j] == 1`），跳过。
  - 否则，路径数由两部分组成：
    - 从上方 \( (i-1, j) \) 移动到当前点；
    - 从左方 \( (i, j-1) \) 移动到当前点。
  - 注意边界情况：如果 \( i == 0 \) 或 \( j == 0 \)，表示没有上方或左方。
---
#### **5. 输出结果**
```cpp
cout << f[n][m];
```
- 输出从 \( (0, 0) \) 到 \( (n, m) \) 的路径总数。
---
### **核心算法分析**
#### 动态规划状态定义
- `f[i][j]`：从起点 \( (0, 0) \) 到达棋盘 \( (i, j) \) 的路径总数。
#### 状态转移方程
- 如果当前点未被马控制：
  \[
  f[i][j] = f[i-1][j] + f[i][j-1]
  \]
  即到达 \( (i, j) \) 的路径总数是从其上方和左方到达的路径总数之和。
#### 边界条件
- 起点路径数初始化为：
  \[
  f[0][0] = 1 - \text{ctr1}[0][0]
  \]
#### 时间复杂度
- 遍历棋盘上的所有点，复杂度为 \( O(n \times m) \)。
#### 空间复杂度
- 使用了二维数组 `f` 和 `ctr1`，复杂度为 \( O(n \times m) \)。
---
### **样例分析**
#### 输入
```
6 6 3 3
```
- 棋盘大小 \( 6 \times 6 \)，目标点 \( (6, 6) \)，马的位置在 \( (3, 3) \)。
#### 输出
```
6
```
- 在不经过马控制点的情况下，从 \( (0, 0) \) 到 \( (6, 6) \) 的所有合法路径总数为 6。
---
### **总结**
该代码利用动态规划高效解决了“过河卒”问题，考虑了马控制点对路径的限制，是一种优雅的解法。

# 11.3 栈
## 题目背景
栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。
栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。
栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。
## 题目描述
![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)
宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。
现在可以进行两种操作，
1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）
使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。
![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)
（原始状态如上图所示）
你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。
## 输入格式
输入文件只含一个整数 $n$（$1 \leq n \leq 18$）。
## 输出格式
输出文件只有一行，即可能输出序列的总数目。
## 样例 #1
### 样例输入 #1
```
3
```
### 样例输出 #1
```
5
```

```cpp
#include<cstdio>
int main(){
    int n,h[20]={1,1};
    scanf("%d",&n);
    for(int i=2;i<=n;i++){
        for(int j=0;j<i;j++){
            h[i]+=h[j]*h[i-j-1];
        }
    }
    printf("%d",h[n]);
    return 0;
}
```
## **代码解析**
### **背景**
这段代码实现了一个经典的动态规划问题：计算栈操作生成的不同输出序列的数量。问题实际上是一个与 **卡塔兰数**（Catalan number）相关的问题，目标是计算可以由操作数序列 \( 1, 2, \ldots, n \) 经过栈操作得到的不同输出序列的总数。
---
### **卡塔兰数背景**
- 卡塔兰数常用于解决以下问题：
  - 给定一组元素，可以生成多少种合法的栈序列。
  - 给定 \( n \) 对括号，能合法配对的方式有多少种。
  - 给定 \( n \) 棵二叉树，能生成多少种不同的树等。
    
卡塔兰数的递推公式为：
\[
C_n = \sum_{i=0}^{n-1} C_i \cdot C_{n-i-1}
\]
其中，\( C_0 = 1 \)，表示没有元素时，只有 1 种排列方式。
---

## 二、递归思想
# 11.4 数的计算
## 题目描述
给出正整数 $n$，要求按如下方式构造数列：
1. 只有一个数 $n$ 的数列是一个合法的数列。
2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。
请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \leq |a|$，使得 $a_i \neq b_i$。
## 输入格式
输入只有一行一个整数，表示 $n$。
## 输出格式
输出一行一个整数，表示合法的数列个数。
## 样例 #1
### 样例输入 #1
```
6
```
### 样例输出 #1
```
6
```
## 提示
### 样例 1 解释
满足条件的数列为：
- $6$
- $6, 1$
- $6, 2$
- $6, 3$
- $6, 2, 1$
- $6, 3, 1$
### 数据规模与约定
对于全部的测试点，保证 $1 \leq n \leq 10^3$。
### 说明
本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：
> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。
>
> 先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：
>
> 1. 不作任何处理；
> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。

## 法一、递归
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,f[1010];
int sol(int x){
    int ans=1;
    if(f[x]!=-1)
        return f[x];
    for(int i=1;i<=x/2;i++){
        ans+=sol(i);
    }
    return f[x]=ans;
}

int main(){
    cin>>n;
    memset(f,-1,sizeof(f));
    f[1]=1;
    cout<<sol(n)<<endl;
}
```

## 解释
这段代码旨在解决 **数列的计算** 问题，通过递归和记忆化搜索的方式来计算给定整数 \( n \) 的所有合法数列的个数。合法的数列满足以下规则：
1. 一个合法的数列可以仅包含数 \( n \) 本身。
2. 在合法的数列末尾加入一个正整数，这个整数必须小于等于当前数列的最后一项的一半。
### **代码解释**
我们逐行分析代码的功能。
```cpp
#include<iostream>
#include<cstring>
using namespace std;

int n, f[1010];  // n 是输入的整数，f 数组存储每个数字的合法数列的个数
```
- `n` 是我们需要处理的正整数，代表要求的数列的目标数。
- `f[1010]` 是一个数组，用来存储每个数字的合法数列个数。数组大小为 \( 1010 \)，因为问题限制了 \( n \leq 1000 \)。
### **`sol(int x)` 函数**
```cpp
int sol(int x){
    int ans = 1;  // 每个数 x 本身就是一个合法的数列
    if (f[x] != -1)  // 如果 f[x] 已经被计算过，直接返回已计算的结果，避免重复计算
        return f[x];

    // 对于每个小于等于 x/2 的数 i，我们递归计算 i 的合法数列个数
    for (int i = 1; i <= x / 2; i++) {
        ans += sol(i);  // 将合法数列的数量累加到 ans 中
    }

    // 存储当前 x 的结果，避免重复计算
    return f[x] = ans;
}
```
- `sol(int x)` 是一个递归函数，用来计算数字 \( x \) 的所有合法数列的个数。
- `ans = 1;` 初始化每个数 \( x \) 本身作为一个合法数列。
- `if (f[x] != -1)` 判断 `f[x]` 是否已经计算过。如果已经计算过（即 `f[x] != -1`），就直接返回存储的结果，避免重复计算。
- 接下来通过 `for (int i = 1; i <= x / 2; i++)` 对 \( x \) 进行递归分解。对于每个 \( i \) 小于等于 \( x/2 \)，递归调用 `sol(i)` 来计算它的合法数列个数，并将其累加到 `ans` 中。
- 最后，将计算结果 `ans` 存储到 `f[x]` 中，供后续调用。
### **`main()` 函数**
```cpp
int main(){
    cin >> n;  // 输入一个正整数 n
    memset(f, -1, sizeof(f));  // 初始化 f 数组为 -1，表示未计算的状态
    f[1] = 1;  // 1 只有一种合法数列，即它本身
    cout << sol(n) << endl;  // 输出 n 的合法数列数量
}
```
- `cin >> n;` 输入一个整数 \( n \)，表示目标数。
- `memset(f, -1, sizeof(f));` 使用 `memset` 函数将数组 `f` 中的每个元素初始化为 `-1`，表示这些位置尚未计算。
- `f[1] = 1;` 对于数字 1，只有一个合法数列，即它本身，因此 `f[1] = 1`。
- 最后，调用 `sol(n)` 计算并输出 \( n \) 的所有合法数列个数。
### **工作原理**
- **递归的核心思想**： 
  - 一个合法数列是由数字 \( n \) 本身开始的，接着可以在末尾继续添加一个不大于 \( n/2 \) 的整数。然后，递归地求解这些整数的合法数列个数，直到不能再添加为止。
  - 比如，对于 \( n = 6 \)，我们可以有以下合法的数列：
    - \( 6 \)
    - \( 6, 1 \)
    - \( 6, 2 \)
    - \( 6, 3 \)
    - \( 6, 2, 1 \)
    - \( 6, 3, 1 \)
- **记忆化搜索**：
  - 使用数组 `f` 存储每个数字的合法数列个数，避免重复计算。例如，对于 \( n = 6 \)，如果我们已经计算过 \( 3 \) 的合法数列个数，那么在计算 \( 6 \) 时就可以直接使用已经计算的结果。
### **时间复杂度**
- 由于使用了记忆化搜索，避免了对同一问题的多次计算。对于每个 \( x \)，我们只需要计算一次它的合法数列个数。
- 最坏情况下，递归调用的深度为 \( n \)，而每个递归最多会访问 \( x/2 \) 个子问题。因此，时间复杂度大约为 \( O(n^2) \)，其中 \( n \) 是输入的整数。
### **空间复杂度**
- 我们使用了大小为 \( n \) 的数组 `f` 来存储每个数字的合法数列个数。因此空间复杂度为 \( O(n) \)。
### **样例说明**
#### 输入：
```
6
```
#### 输出：
```
6
```
#### 解释：
对于 \( n = 6 \)，合法的数列有：
1. \( 6 \)
2. \( 6, 1 \)
3. \( 6, 2 \)
4. \( 6, 3 \)
5. \( 6, 2, 1 \)
6. \( 6, 3, 1 \)
总共有 6 种合法的数列，因此输出 6。
### **总结**
这段代码通过递归和记忆化搜索的方式计算了所有合法数列的个数。通过动态规划的思想避免了重复计算，从而提高了效率。对于 \( n \leq 1000 \) 的问题，使用该算法能够在合理的时间内得到正确答案。

## 法二、递推
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n, dp[1010];  // dp数组用于存储每个数字的合法数列个数
int main() {
    cin >> n;
    dp[1] = 1;
    for (int x = 2; x <= n; x++) {
        dp[x] = 1;  // 数列只包含数字 x 本身
        for (int i = 1; i <= x / 2; i++) {
            dp[x] += dp[i];  // 将 dp[i] 添加到 dp[x] 上
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```

# 11.5 Function
## 题目描述
对于一个递归函数 $w(a,b,c)$
- 如果 $a \le 0$ 或 $b \le 0$ 或 $c \le 0$ 就返回值 $1$。
- 如果 $a>20$ 或 $b>20$ 或 $c>20$ 就返回 $w(20,20,20)$
- 如果 $a<b$ 并且 $b<c$ 就返回 $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$。
- 其它的情况就返回 $w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$
这是个简单的递归函数，但实现起来可能会有些问题。当 $a,b,c$ 均为 $15$ 时，调用的次数将非常的多。你要想个办法才行。
注意：例如 $w(30,-1,0)$ 又满足条件 $1$ 又满足条件 $2$，请按照最上面的条件来算，答案为 $1$。
## 输入格式
会有若干行。
并以 $-1,-1,-1$ 结束。
## 输出格式
输出若干行，每一行格式：
`w(a, b, c) = ans`
注意空格。
## 样例 #1
### 样例输入 #1
```
1 1 1
2 2 2
-1 -1 -1
```
### 样例输出 #1
```
w(1, 1, 1) = 2
w(2, 2, 2) = 4
```
## 提示
### 数据规模与约定
保证输入的数在 $[-9223372036854775808,9223372036854775807]$ 之间，并且是整数。
保证不包括 $-1, -1, -1$ 的输入行数 $T$ 满足 $1 \leq T \leq 10 ^ 5$。

```cpp
#include<iostream>
using namespace std;
long long f[25][25][25];
long long w(long long a, long long b, long long c) {
    if (a <= 0 || b <= 0 || c <= 0)  return 1;
    else if (a > 20 || b > 20 || c > 20)   return w(20, 20, 20);
    else if (f[a][b][c] != 0)  return f[a][b][c];
    else if (a < b && b < c)
        f[a][b][c] = w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);
    else
        f[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1)-w(a-1, b-1, c-1);
    return f[a][b][c];
}

int main() {
    long long a, b, c;
    while (cin >> a >> b >> c) {
        if (a == -1 && b == -1 && c == -1)
            break;
        cout << "w(" << a << ", " << b << ", " << c << ") = ";
        cout << w(a, b, c) << endl;
    }
}
```

# 11.2 外星密码
## 题目描述
有了防护伞，并不能完全避免 2012 的灾难。地球防卫小队决定去求助外星种族的帮助。经过很长时间的努力，小队终于收到了外星生命的回信。但是外星人发过来的却是一串密码。只有解开密码，才能知道外星人给的准确回复。解开密码的第一道工序就是解压缩密码，外星人对于连续的若干个相同的子串 $\texttt{X}$ 会压缩为 $\texttt{[DX]}$ 的形式（$D$ 是一个整数且 $1\leq D\leq99$），比如说字符串 $\texttt{CBCBCBCB}$ 就压缩为 $\texttt{[4CB]}$ 或者$\texttt{[2[2CB]]}$，类似于后面这种压缩之后再压缩的称为二重压缩。如果是 $\texttt{[2[2[2CB]]]}$ 则是三重的。现在我们给你外星人发送的密码，请你对其进行解压缩。
## 输入格式
输入一行，一个字符串，表示外星人发送的密码。
## 输出格式
输出一行，一个字符串，表示解压缩后的结果。
## 样例 #1
### 样例输入 #1
```
AC[3FUN]
```
### 样例输出 #1
```
ACFUNFUNFUN
```
## 提示
【数据范围】
对于 $50\%$ 的数据：解压后的字符串长度在 $1000$ 以内，最多只有三重压缩。
对于 $100\%$ 的数据：解压后的字符串长度在 $20000$ 以内，最多只有十重压缩。保证只包含数字、大写字母、`[` 和 `]`。

```cpp
#include<iostream>
#include<string>
using namespace std;
string expand(){
    string s="",X;
    char c;
    int D  ;
    while(cin>>c){
        if(c=='['){
            cin>>D;
            X=expand();
            while(D--)
                s+=X;
        }
        else if(c==']')  return s;
        else s+=c;
    }
    return s;
}

int main(){
    cout<<expand();
    return 0;
}
```

# END
