如果你想在算法竞赛中得奖，就要尽可能多读书、多思考、多练习。去完成尽可能多数量与种类的算法题目积累知识和经验，在考场上放平心态，就可以达到目标。但因为花了太多时间在编程上而极度压缩休息的时间，反而会效率低下，得不偿失。很多时候太贪婪不是一件好事，因为目光短浅，没有考虑到后面的事情，结果没有办法保证最后的结果做到最好。
在算法竞赛中求解某些问题时，只需要做出在当前看来是最好的选择就能获得最好的结果，而不需要考虑整体上的最优，即使目光短浅也是没有关系的。本章就介绍这样的贪心策略。

# 12.1 部分背包问题
## 题目描述
阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？
## 输入格式
第一行两个整数 $N,T$。
接下来 $N$ 行，每行两个整数 $m_i,v_i$。
## 输出格式
一个实数表示答案，输出两位小数
## 样例 #1
### 样例输入 #1
```
4 50
10 60
20 100
30 120
15 45
```
### 样例输出 #1
```
240.00
```

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct coin{
    int m,v;
}a[110];

bool cmp(coin x,coin y){
    return x.v*y.m>y.v*x.m;
}

int main(){
    int n,t,c,i;
    float ans=0;
    scanf("%d%d",&n,&t);
    c=t;
    for(i=0;i<n;i++)
        scanf("%d%d",&a[i].m,&a[i].v);
    sort(a,a+n,cmp);
    for(i=0;i<n;i++){
        if(a[i].m>c)
            break;
        c-=a[i].m;
        ans+=a[i].v;
    }
    if(i<n)
        ans+=1.0*c/a[i].m*a[i].v;
    printf("%.2lf",ans);
    return 0;
}
```

# 12.2 排队接水
## 题目描述
有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。
## 输入格式
第一行为一个整数 $n$。
第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。
## 输出格式
输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。
## 样例 #1
### 样例输入 #1
```
10 
56 12 1 99 1000 234 33 55 99 812
```
### 样例输出 #1
```
3 2 7 8 1 4 9 6 10 5
291.90
```
## 提示
$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。

```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
struct water {
    int num, time;
}p[1010];
bool cmp(water a, water b) {
    if (a.time != b.time)
        return a.time < b.time;
    return a.num < b.num;
}
int n;
long long sum=0;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d",&p[i].time);
        p[i].num = i;
    }
    sort(p+1, p + n+1, cmp);
    for (int i = 1; i <= n; i++) {
        printf("%d ", p[i].num);
        sum += i * p[n - i].time;
    }
    printf("\n%.2lf\n", 1.0 * sum / n);
    return 0;
}
```

# 12.3 凌乱的yyy / 线段覆盖（数学归纳法）
## 题目背景
快 noip 了，yyy 很紧张！
## 题目描述
现在各大 oj 上有 $n$ 个比赛，每个比赛的开始、结束的时间点是知道的。
yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。
所以，他想知道他最多能参加几个比赛。
由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 $2$ 个及以上的比赛。
## 输入格式
第一行是一个整数 $n$，接下来 $n$ 行每行是 $2$ 个整数 $a_{i},b_{i}\ (a_{i}<b_{i})$，表示比赛开始、结束的时间。
## 输出格式
一个整数最多参加的比赛数目。
## 样例 #1
### 样例输入 #1
```
3
0 2
2 4
1 3
```
### 样例输出 #1
```
2
```
## 提示
- 对于 $20\%$ 的数据，$n \le 10$；
- 对于 $50\%$ 的数据，$n \le 10^3$；
- 对于 $70\%$ 的数据，$n \le 10^{5}$；
- 对于 $100\%$ 的数据，$1\le n \le 10^{6}$，$0 \le a_{i} < b_{i} \le 10^6$。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n, ans = 0, finish = 0;
struct contest {
	int l, r;
}con[1000010];

bool cmp(contest a, contest b) {
	return a.r <= b.r;
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> con[i].l >> con[i].r;
	}
	sort(con + 1, con + 1 + n, cmp);
	for (int i = 1; i <= n; i++) {
		if (finish <= con[i].l)
			ans++, finish = con[i].r;
	}
	cout << ans << endl;
	return 0;
}
```

## 12.4 分卷子
## 解答
思想：数量越多等级的卷子应先分出来，数量少等级的卷子可以多分几次，可以减少分卷次数
运用贪心思想解决：从最开始分出最多等级的卷子，然后分出第二多的卷子······
但是，这是错的。
正解：逆向思维，分成最小的组，逐渐合并，使组合尽可能小

# 12.5 合并果子
## 题目描述
在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。
每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。
因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。
例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。
## 输入格式
共两行。  
第一行是一个整数 $n(1\leq n\leq 10000)$ ，表示果子的种类数。  
第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\leq a_i\leq 20000)$ 是第 $i$ 种果子的数目。
## 输出格式
一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$ 。
## 样例 #1
### 样例输入 #1
```
3 
1 2 9
```
### 样例输出 #1
```
15
```
## 提示
对于 $30\%$ 的数据，保证有 $n \le 1000$：
对于 $50\%$ 的数据，保证有 $n \le 5000$；
对于全部的数据，保证有 $n \le 10000$。

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

int n, n2, a1[10010], a2[10010], sum = 0;
int main() {
	cin >> n;
	memset(a1, 127, sizeof(a1));
	memset(a2, 127, sizeof(a2));
	for (int i = 0; i < n; i++) {
		cin >> a1[i];
	}

	sort(a1, a1 + n);
	int i = 0, j = 0, k, w;
	for (k = 1; k < n; k++) {
		w = a1[i] < a2[j] ? a1[i++] : a2[j++];
		w += a1[i] < a2[j] ? a1[i++] : a2[j++];
		a2[n2++] = w;
		sum += w;
	}

	cout << sum;
}
```
