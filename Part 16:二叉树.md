我们之前介绍了线性表这一类数据结构，并且学习了如何使用线性表解决一类特定的问题（数据具有明显的前后关系，可以进行线性连接）。本章将介绍一类新的数据结构——二叉树。
看看窗外的橡树吧。一般来说，树有一个粗壮的树干，再往上面树干就会分成两叉或者多叉，接着树枝会继续一直分下去，一直分到末端的叶子为止（不过也有可能是花或者果子）。
如想统计一棵苹果树上面有多少苹果，只需要知道树杈左边的苹果数量和树杈右边的苹果数量，然后计算它们的和就行了。至于树杈左边有多少个苹果？可以使用一样的方法来统计，把这个分枝当作树干，然后统计这个树干的左分杈和右分杈的苹果数量和……直到统计到树枝末端每一个苹果，然后依次汇总就可以得到苹果的数量 。
很明显，树形结构不仅能表示数据间的指向关系，还能表示出数据的层次关系，而有很明显的递归性质。因此，我们可以利用树的性质解决更多种类的问题。

# 一、二叉树概念和建立
二叉树是一种特殊的树，每次分叉不超过两部分。
# 16.1 淘汰赛
## 题目描述
有 $2^n$（$n\le7$）个国家参加世界杯决赛圈且进入淘汰赛环节。已经知道各个国家的能力值，且都不相等。能力值高的国家和能力值低的国家踢比赛时高者获胜。1 号国家和 2 号国家踢一场比赛，胜者晋级。3 号国家和 4 号国家也踢一场，胜者晋级……晋级后的国家用相同的方法继续完成赛程，直到决出冠军。给出各个国家的能力值，请问亚军是哪个国家？
## 输入格式
第一行一个整数 $n$，表示一共 $2^n$ 个国家参赛。
第二行 $2^n$ 个整数，第 $i$ 个整数表示编号为 $i$ 的国家的能力值（$1\leq i \leq 2^n$）。
数据保证不存在平局。
## 输出格式
仅一个整数，表示亚军国家的编号。
## 输入输出样例 #1
### 输入 #1
```
3
4 2 3 1 10 5 9 7
```
### 输出 #1
```
1
```

```cppp
#include<cstdio>
#include<iostream>
using namespace std;
int value[260],winner[260];
int n;
void dfs(int x){
    if(x>=1<<n)
        return;
    else{
        dfs(2*x);
        dfs(2*x+1);
        int lvalue=value[2*x],rvalue=value[2*x+1];
        if(lvalue>rvalue){
            value[x]=lvalue;
            winner[x]=winner[2*x];
        }else{
            value[x]=rvalue;
            winner[x]=winner[2*x+1];
        }
    }
}

int main(){
    cin>>n;
    for(int i=0;i<1<<n;i++){
        cin>>value[i+(1<<n)];
        winner[i+(1<<n)]=i+1;
    }
    dfs(1);
    cout<<(value[2] > value[3]?winner[3]:winner[2]);
    return 0;
}
```
注：原书中代码三元表达式需要加括号

考虑到这是一个完美二叉树，1到(1<<n)-1编号都是非子结点，编号不小于1<<n都是叶子结点。本题使用value[i]来记录叶子结点的实力值，或是非子结点的改子树的最大值；使用winner[i]来记录该子树的获胜者。当所有比赛模拟完毕，winnner[1]记录了整场比赛的冠军，value[i]记录了冠军的实力值。这时比较一下谁是决赛败者，输出败者的国家编号，即整场比赛的亚军。
由于需要维护和子树相关的两个值————
