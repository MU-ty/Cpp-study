有时候，我们并不关心数据之间的前后关系，也不关心数据的层次关系。一些确定元素只是单纯的聚集在一起，这样的元素聚集体被称为集合。
当希望知道某个数据是否存在一个集合中，或者两个元素是否在同一个集合中时，就需要使用一些集合数据结构来维护集合元素之间的关系。
# 一、 并查集
# 17.1 亲戚
## 题目背景
若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。
## 题目描述
规定：$x$ 和 $y$ 是亲戚，$y$ 和 $z$ 是亲戚，那么 $x$ 和 $z$ 也是亲戚。如果 $x$，$y$ 是亲戚，那么 $x$ 的亲戚都是 $y$ 的亲戚，$y$ 的亲戚也都是 $x$ 的亲戚。
## 输入格式
第一行：三个整数 $n,m,p$，（$n,m,p \le 5000$），分别表示有 $n$ 个人，$m$ 个亲戚关系，询问 $p$ 对亲戚关系。
以下 $m$ 行：每行两个数 $M_i$，$M_j$，$1 \le M_i,~M_j\le n$，表示 $M_i$ 和 $M_j$ 具有亲戚关系。
接下来 $p$ 行：每行两个数 $P_i,P_j$，询问 $P_i$ 和 $P_j$ 是否具有亲戚关系。
## 输出格式
$p$ 行，每行一个 `Yes` 或 `No`。表示第 $i$ 个询问的答案为“具有”或“不具有”亲戚关系。
## 输入输出样例 #1
### 输入 #1
```
6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6
```
### 输出 #1
```
Yes
Yes
No
```

```cpp
#include<iostream>
#define MAXN 5010
using namespace std;
int n, m, p, x, y;
int fa[MAXN]; //表示元素i的父结点

int find(int x) {
	if (x == fa[x]) //如果x的父节点是自己，说明x就是这个集合的根节点。
		return x;
	return fa[x] = find(fa[x]); //否则递归查找 x 的父节点，直到找到根节点。在查找的过程中，路径压缩：将路径上所有节点的父节点直接指向根节点，从而加速未来的查找。
}

void join(int c1, int c2) {
	int f1 = find(c1), f2 = find(c2);
	if (f1 != f2)
		fa[f1] = f2;
}

int main() {
	cin >> n >> m >> p;
	for (int i = 1; i <= n; i++)
		fa[i] = i;
	for (int i = 0; i < m; ++i) {
		cin >> x >> y;
		join(x, y);
	}
	for (int i = 0; i < p; i++) {
		cin >> x >> y;
		if (find(x) == find(y))
			cout << "Yes" << endl;
		else
			cout << "No" << endl;
	}
	return 0;
}
```
路径压缩：一棵树上每个节点离根越近越好，因此访问一个结点的同时将所有访问到的结点的负责人都设为族长，这样下一次结点找族长经过的结点数就会大大减少，这就是fa[x]=find(fa[x])语句。
注：仅进行路径压缩时间复杂度缩短至O(logn)，还可以进行按秩合并优化（树的深度小的一方的族长指向深度大的一方），将查询复杂度优化至接近常数。

# 17.2 村村通
## 题目描述
某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 "村村通工程" 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？
## 输入格式
输入包含若干组测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目 $n$ 和道路数目 $m$ ；随后的 $m$ 行对应 $m$ 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 $1$ 到 $n$ 编号。
注意：两个城市间可以有多条道路相通。
**在输入数据的最后，为一行一个整数 $0$，代表测试数据的结尾。**
## 输出格式
对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。
## 输入输出样例 #1
### 输入 #1
```
4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
```
### 输出 #1
```
1
0
2
998
```
## 说明/提示
#### 数据规模与约定
对于 $100\%$ 的数据，保证 $1 \le n < 1000$ 。

```cpp
#include<iostream>
#define MAXN 5010
using namespace std;

int n, m, p, x, y;
int fa[MAXN];

// 查找操作，带路径压缩
int find(int x) {
    if (x == fa[x])  // 如果 x 是自己的父节点，说明它是根
        return x;
    return fa[x] = find(fa[x]);  // 路径压缩
}

// 合并操作
void join(int c1, int c2) {
    int f1 = find(c1), f2 = find(c2);
    if (f1 != f2)
        fa[f1] = f2;  // 将 f1 所在的集合合并到 f2 所在的集合
}

int main() {
    while (true) {
        cin >> n >> m;
        if (n == 0) break;  // 结束条件

        // 初始化并查集，每个城镇的父节点初始为自己
        for (int i = 1; i <= n; i++)
            fa[i] = i;

        // 处理 m 条道路，连接相应的城镇
        for (int i = 0; i < m; ++i) {
            cin >> x >> y;
            join(x, y);
        }

        // 计算连通分量的个数
        int connected_components = 0;
        for (int i = 1; i <= n; i++) {
            if (find(i) == i)  // 如果 i 是根节点，说明它是一个新连通分量
                connected_components++;
        }

        // 最少需要建设的道路数是连通分量数 - 1
        cout << connected_components - 1 << endl;
    }

    return 0;
}
```

