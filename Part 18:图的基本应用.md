我们已经学过一些简单的数据结构，例如线性表和二叉树。现在，需要学习一种新的数据结构——图。虽然相比于前面讲过的数据结构，图会复杂一些，但是依然能用很多生活中存在的例子来解释图这种数据结构。
比如，现在新同学站在校园的正门口，手里拿着校园地图。可以从地图上看到有很多建筑物。复杂的路网四通八达，连接着这些建筑物。如果希望偷个懒，走最近的道路到达目的地，或者是希望制定一种方案，参观完学校内的每一种建筑物，都可以使用“图”这一数据结构来模拟。通过建模，编写计算机程序，就可以解决这类问题。
#一、图的基本概念和建立
## 18.1 爱华中学的地图
每个建筑物称为顶点，建筑物之间联通的道路称为边，而图这种数据结构就是这些顶点和关联这些顶点的边的集合。
无向图中，一个结点连边的条数称作这个结点的度数。
每一条边的属性值就是边权，除了边权之外，每个顶点也可以有属性值，称为点权，两个顶点之间如果不只有一条边直接连接，称为重边，甚至可能出现一条边的起点终点是一样的，造成自环。
在大多数情况下，自环和重边会被简化掉（比如删除自环，同样两个顶点中的多条边只会保留最短的一条）。

##18.2 图的存储
现希望将第二张图和第三张图存进计算机
当没有重边的情况下，使用邻接矩阵最为直观。
可以发现在无向图中右上和左下是对称的，也就是说v[i][j]和v[j][i]是相同的
很显然，因为点i和j双向连通，边权相同。如果忽略边权，只关心两点直接是否有边直接相连，那么可以把边权视为1；如果v[i][j]是0，说明点i和点j之间没有直接连接。
对于有向图来说，邻接矩阵不一定对称，每一条从i到j的单项道路的数据都会被记录在v[i][j]。
同理如果v[i][j]是0，说明点i到j没有直接连接的单项道路，有向图中，一个结点向别的连边的条数称为作为这个结点的出度，别的结点连边到一个结点的条数作为这个结点的入度。
可以写出邻接矩阵的代码：
```cpp
#include<iostream>
#define MAXN 1005
using namespace std;
int n;
int v[MAXN][MAXN];
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> v[i][j];
		}
	}
  //下面的代码将找到与点i有直接连接的每一个点以及那条边的长度
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (v[i][j] > 0) {
				cout << "edge from point " << i << " to point" << j << " with length" << v[i][j] << '\n';
			}
		}
	}
	return 0;
}
```
