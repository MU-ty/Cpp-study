我们已经学过一些简单的数据结构，例如线性表和二叉树。现在，需要学习一种新的数据结构——图。虽然相比于前面讲过的数据结构，图会复杂一些，但是依然能用很多生活中存在的例子来解释图这种数据结构。
比如，现在新同学站在校园的正门口，手里拿着校园地图。可以从地图上看到有很多建筑物。复杂的路网四通八达，连接着这些建筑物。如果希望偷个懒，走最近的道路到达目的地，或者是希望制定一种方案，参观完学校内的每一种建筑物，都可以使用“图”这一数据结构来模拟。通过建模，编写计算机程序，就可以解决这类问题。
#一、图的基本概念和建立
## 18.1 爱华中学的地图
每个建筑物称为顶点，建筑物之间联通的道路称为边，而图这种数据结构就是这些顶点和关联这些顶点的边的集合。
无向图中，一个结点连边的条数称作这个结点的度数。
每一条边的属性值就是边权，除了边权之外，每个顶点也可以有属性值，称为点权，两个顶点之间如果不只有一条边直接连接，称为重边，甚至可能出现一条边的起点终点是一样的，造成自环。
在大多数情况下，自环和重边会被简化掉（比如删除自环，同样两个顶点中的多条边只会保留最短的一条）。

## 18.2 图的存储
现希望将第二张图和第三张图存进计算机
当没有重边的情况下，使用邻接矩阵最为直观。
可以发现在无向图中右上和左下是对称的，也就是说v[i][j]和v[j][i]是相同的
很显然，因为点i和j双向连通，边权相同。如果忽略边权，只关心两点直接是否有边直接相连，那么可以把边权视为1；如果v[i][j]是0，说明点i和点j之间没有直接连接。
对于有向图来说，邻接矩阵不一定对称，每一条从i到j的单项道路的数据都会被记录在v[i][j]。
同理如果v[i][j]是0，说明点i到j没有直接连接的单项道路，有向图中，一个结点向别的连边的条数称为作为这个结点的出度，别的结点连边到一个结点的条数作为这个结点的入度。
可以写出邻接矩阵的代码：
```cpp
#include<iostream>
#define MAXN 1005
using namespace std;
int n;
int v[MAXN][MAXN];
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> v[i][j];
		}
	}
  //下面的代码将找到与点i有直接连接的每一个点以及那条边的长度
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (v[i][j] > 0) {
				cout << "edge from point " << i << " to point" << j << " with length" << v[i][j] << '\n';
			}
		}
	}
	return 0;
}
```
对于一个有n个点m条边的图，在使用邻接矩阵时，虽然可以直接得到每两个点之间的边权，但是为了存储这些边权，需要开一个n*m的数组，即有$O(n^2)$的空间复杂度；如需要得到图上所有的边，就需要遍历整个n*n数组，即遍历时有有O(n^2)的时间复杂度。
邻接矩阵地时间复杂度和空间复杂度都较大，在大多数情况下效率较低，尤其是当图比较稀疏（边数远没有达到点数的平方）时。因此，在存图时，更常用的是邻接表。
为了便于解释，接下来先用有向图解释，邻接表的思想，对于一条有向边<i,j>，并不需要用n*n的二维数组来存下其他点是否存在边，而只需要一个点能到达的顶点和相应边的边长集合即可。
为了存下这个集合，又需要开一个二维数组，第一维i表示起点，第二维j表示是点i的第j条边。如果仍然使用普通的数组，那么使用的数组大小仍然是n*n，因为每个点很可能不会与其他n-1个点都有边，所以只需要在第二维中有几条边就定义多大数组。
这个功能可以使用vector来实现。首先定义一个edge结构体，里面有两个变量to和cost，表示一条边的终点和边权。每当读入一条边<u,v,l>，用p[u].push_back((edge){v,l})来表示为点u增加一条终点为v边权为l的边。
如果想知道点u有多少条边，可以使用命令p[u].size()，另外，在解决其他问题时，如果想清除点u的所有边，可以使用命令p[u].clear()。
输入一个有向图的点数、边数、每一条边的起点终点边权，输出有向图的邻接矩阵，代码如下：
```cpp
#include<iostream>
#include<vector>
#define MAXN 1005
using namespace std;
struct edge {
	int to, cost;
};
int n, m;
vector<edge>p[MAXN];
int v[MAXN][MAXN];
int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v, l;
		cin >> u >> v >> l;
		p[u].push_back((edge){
			v, l
		});
	}

	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < p[i].size(); j++)
			v[i][p[i][j].to] = p[i][j].cost;
	}

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cout << v[i][j] << ' ';
		}
		cout << '\n';
	}
}
```
可以发现，对于每条边，只会被插入到一个vector里面，且只插入一次，而总的边数是O(m)的，所以空间复杂度是O(m)，当m比$n^2$小很多时，这里的空间优势就很明显了，但是，如果需要指定查询或修改边<i,j>的边权，因为并不知道这条边的具体存放位置，所以需要通过遍历以i为起点的所有边来找到这条边，需要的时间复杂度为O(n)。在这一点上，邻接表的复杂度不如邻接矩阵O(1)要来的优。
#二、图的遍历
## 18.3 查找文献
## 题目描述
小 K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小 K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。
假设洛谷博客里面一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及 $m(m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。
这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。不保证编号为 1 的文章没有被其他文章引用。
![](https://cdn.luogu.com.cn/upload/image_hosting/f4n4tlhi.png)
请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。
## 输入格式
共 $m+1$ 行，第 1 行为 2 个数，$n$ 和 $m$，分别表示一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及$m(m\le10^6)$ 条参考文献引用关系。
接下来 $m$ 行，每行有两个整数 $X,Y$ 表示文章 X 有参考文献 Y。
## 输出格式
共 2 行。
第一行为 DFS 遍历结果，第二行为 BFS 遍历结果。
## 输入输出样例 #1
### 输入 #1
```
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8
```
### 输出 #1
```
1 2 5 6 3 7 8 4 
1 2 3 4 5 6 7 8
```

分析：可以把每个洛谷博客看作一个结点，每条参考文献引用关系看作一条边，把这个问题抽象为一个图论问题，不重复、不遗漏地看完所有他能看到的文章即相当于遍历整个图。如何不重复、不遗漏地遍历整个图？
为了不重复地遍历整个图，定义一个vis数组，表示每个结点是否被遍历过，在遍历时经过每个结点的时候，马上将这个结点的vis设为1，然后在经历每个结点之前，都判断这个结点的vis是否为0，即没被访问过，如果vis不是0，则不再经过这个结点，这样就做到了不重复地遍历这个图。
为了不遗漏地遍历这个图，依次枚举这个图上的所有结点，如果这个结点没有被访问过，访问这个结点，并且按照题目的规则，需要访问这个结点连边连向的所有结点，依此类推。
如何确保访问到所有的结点，思路一深度优先遍历，思路二广度优遍历。
思路一：深度优先遍历
从一枝开始遍历，直至遍历完；；然后从第二枝开始遍历，以此类推
```cpp
#include<bits/stdc++.h>
#define MAXN 100005
using namespace std;
int n, m;
vector <int> p[MAXN];
bool u[MAXN];
void solve(int x) {
	cout << x << ' ';
	for (int i = 0, sz = p[x].size(); i < sz; i++) {
		if (!u[p[x][i]]) {
			u[p[x][i]] = true;
			solve(p[x][i]);
		}
	}
}
int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		p[x].push_back(y);
	}
	u[1] = true;
	solve(1);
	return 0;
}
```
思路2：广度优先搜索
一层一层遍历，遍历完一层，遍历下一层
```cpp
#include<bits/stdc++.h>
#define MAXN 100005
using namespace std;
int n, m;
vector <int> p[MAXN];
bool u[MAXN];
queue<int> q;
bool u[MAXN];
int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		p[x].push_back(y);
	}
	u[1] = true;
	q.push(1);
	while (!q.empty()) {
		int x = q.front();
		q.pop();
		cout << x << ' ';
		for(int i=0,sz=p[x].size();i<sz;i++)
			if (!u[p[x][i]]) {
				u[p[x][i]] = true;
				q.push(p[x][i]);
			}
	}
	return 0;
}
```
深度优先遍历可以看作在图中的深度优先搜索（DFS），广度优先遍历（BFS）可以看作在图中的广度优先搜索。
提交答案：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#define MAXN 100005
using namespace std;

int n, m;
vector<int> p[MAXN];
bool u[MAXN];

void dfs(int x) {
    cout << x << ' ';
    for (int i = 0, sz = p[x].size(); i < sz; i++) {
        if (!u[p[x][i]]) {
            u[p[x][i]] = true;
            dfs(p[x][i]);
        }
    }
}

void bfs(int start) {
    queue<int> q;
    q.push(start);
    u[start] = true;
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        cout << x << ' ';
        for (int i = 0, sz = p[x].size(); i < sz; i++) {
            if (!u[p[x][i]]) {
                u[p[x][i]] = true;
                q.push(p[x][i]);
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        p[x].push_back(y);
    }

    // 对每个节点的邻接列表进行排序
    for (int i = 1; i <= n; i++) {
        sort(p[i].begin(), p[i].end());
    }

    // DFS遍历
    fill(u, u + MAXN, false);
    u[1] = true;
    dfs(1);
    cout << endl;

    // BFS遍历
    fill(u, u + MAXN, false);
    u[1] = true;
    bfs(1);
    cout << endl;

    return 0;
}
```
