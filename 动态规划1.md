# P2842 纸币问题 1

## 题目描述

某国有 $n$ 种纸币，每种纸币面额为 $a_i$ 并且有无限张，现在要凑出 $w$ 的金额，试问最少用多少张纸币可以凑出来？

## 输入格式

第一行两个整数 $n,w$，分别表示纸币的种数和要凑出的金额。  
第二行一行 $n$ 个以空格隔开的整数 $a_1, a_2, a_3, \dots a_n$ 依次表示这 $n$ 种纸币的面额。

## 输出格式

一行一个整数，表示最少使用的纸币张数。

## 输入输出样例 #1

### 输入 #1

```
6 15
1 5 10 20 50 100
```

### 输出 #1

```
2
```

## 输入输出样例 #2

### 输入 #2

```
3 15
1 5 11
```

### 输出 #2

```
3
```

## 说明/提示

对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i \leq w\le 10^4$。

```
#include <bits/stdc++.h>
using namespace std;
#define INF 2000000000

int f[10010], a[1010];

int main() {
    int n, w;
    scanf("%d%d", &n, &w); 
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= w; i++) f[i] = INF; 
    f[0] = 0;
    for (int j = 1; j <= n; j++) {  
        for (int i = a[j]; i <= w; i++) {
            f[i] = min(f[i], f[i - a[j]] + 1);
        }
    }
    printf("%d\n", f[w]);
    return 0;
}
```

我们用样例：

```
3 15
1 5 11
```

来详细演示**完全背包动态规划**的全过程。

---

## 1. 初始化

- 有 3 种纸币，面额分别为 1、5、11。
- 目标金额 w = 15。
- 定义 `f[x]` 表示拼出金额 x 所需的最少纸币数。

初始状态：
- `f[0] = 0`（0元不需要纸币）
- 其它 `f[1~15] = INF`（初始为极大值）

---

## 2. 动态规划转移

我们依次用每种面额的纸币，更新所有金额的最优解。

### 用面额 1 的纸币

对于所有 i 从 1 到 15：

- `f[i] = min(f[i], f[i-1] + 1)`
- 因为只能用1元，那每加1元就多用一张。

结果（只用1元纸币时）：

| 金额 i | f[i] |
|-------|------|
| 0     | 0    |
| 1     | 1    |
| 2     | 2    |
| 3     | 3    |
| 4     | 4    |
| 5     | 5    |
| 6     | 6    |
| 7     | 7    |
| 8     | 8    |
| 9     | 9    |
| 10    | 10   |
| 11    | 11   |
| 12    | 12   |
| 13    | 13   |
| 14    | 14   |
| 15    | 15   |

---

### 用面额 5 的纸币

从 5 到 15：

- `f[i] = min(f[i], f[i-5] + 1)`

逐步更新：

- f[5] = min(5, 0+1) = 1
- f[6] = min(6, 1+1) = 2
- f[7] = min(7, 2+1) = 3
- f[8] = min(8, 3+1) = 4
- f[9] = min(9, 4+1) = 5
- f[10] = min(10, 5+1) = 2
- f[11] = min(11, 6+1) = 3
- f[12] = min(12, 7+1) = 4
- f[13] = min(13, 8+1) = 5
- f[14] = min(14, 9+1) = 6
- f[15] = min(15, 10+1) = 3

结果（使用了1和5元纸币后）：

| 金额 i | f[i] |
|-------|------|
| 0     | 0    |
| 1     | 1    |
| 2     | 2    |
| 3     | 3    |
| 4     | 4    |
| 5     | 1    |
| 6     | 2    |
| 7     | 3    |
| 8     | 4    |
| 9     | 5    |
| 10    | 2    |
| 11    | 3    |
| 12    | 4    |
| 13    | 5    |
| 14    | 6    |
| 15    | 3    |

---

### 用面额 11 的纸币

从 11 到 15：

- f[11] = min(3, f[0]+1) = min(3, 1) = 1
- f[12] = min(4, f[1]+1) = min(4, 2) = 2
- f[13] = min(5, f[2]+1) = min(5, 3) = 3
- f[14] = min(6, f[3]+1) = min(6, 4) = 4
- f[15] = min(3, f[4]+1) = min(3, 5) = 3

最终结果：

| 金额 i | f[i] |
|-------|------|
| 0     | 0    |
| 1     | 1    |
| 2     | 2    |
| 3     | 3    |
| 4     | 4    |
| 5     | 1    |
| 6     | 2    |
| 7     | 3    |
| 8     | 4    |
| 9     | 5    |
| 10    | 2    |
| 11    | 1    |
| 12    | 2    |
| 13    | 3    |
| 14    | 4    |
| 15    | 3    |

---

## 3. 输出

目标金额 15，`f[15] = 3`  
即：最少需要 3 张纸币。

---

## 4. 方案举例

比如可以是：一张11元+一张1元+一张1元+一张1元+一张1元 = 15元（共5张，但不是最优），
或者三张5元=15元（但没有三张5元的方案，因为f[15]=3不是由5元构成）

实际上，最优方案（f[15]=3）：
- 11元+1元+1元+1元+1元 = 15元（但这其实是5张，不是3张）
- 5元+5元+5元 = 15元（三张），但从DP表推导来看，f[15]=3，是由f[10]=2（两张）+5元（1张）得到的。
- f[10]=2 有哪些方案？可以是5+5，也可以是10（但没有10元纸币），所以只能5+5。
- 所以，f[15]=3，方案是5+5+5。

---

## 5. 总结

- **DP表每一格代表拼出该金额的最少纸币数。**
- **每一种面额都尝试更新所有能拼出的金额。**
- **最后`f[15]`就是答案。**

---
