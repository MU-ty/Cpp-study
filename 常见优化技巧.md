评价算法的标准，除了正确性以外，最重要的就是程序的运行效率是否足够高，是否可以在 限定的时间内处理完指定的数据。在“暴力枚举”一章中介绍了可以通过剔除无效操作来提升算 法效率。除此之外，还可以用“单调性”和“空间换时间”来优化时间复杂度。将这两种思想结 合，产生了单调栈和单调队列等工具。
这些技巧可以帮助我们排除无效选项，在一定范围内保持单调性，常常可以将一些问题求解 的时间复杂度降到O(n)，因此称为线性时间复杂度优化。
# 一、双指针法
## 1.1 A-B数对
## 题目背景
出题是一件痛苦的事情！
相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！
## 题目描述
给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。
## 输入格式
输入共两行。
第一行，两个正整数 $N,C$。
第二行，$N$ 个正整数，作为要求处理的那串数。
## 输出格式
一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。
## 输入输出样例 #1
### 输入 #1
```
4 1
1 1 2 3
```
### 输出 #1
```
3
```
## 说明/提示
对于 $75\%$ 的数据，$1 \leq N \leq 2000$。
对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 200010
int s[MAXN];
int main() {
	int n, c;
	cin >> n >> c;
	for (int i = 0; i < n; i++)
		cin >> s[i];
	sort(s, s + n);
	int l = 0, r = 0;
	long long sum = 0;
	for (int i = 0; i < n; i++) {
		while (s[l] < s[i] - c && l < n)
			l++;
		while (s[r] <= s[i] - c && r < n)
			r++;
		if (s[i] - s[l] == c) {
			sum += r - l;
		}
	}
	cout << sum << endl;
	return 0;
}
```
解释：对于s[i]，我们要找的是s[i]-c。
如果s[i]-c存在，则一定在排序后的数列中是连续出现的（已排序）。
维护两个指针，左指针l和右指针r，使得s[l]是首个大于或等于s[i]-c的数，s[r]是首个大于s[i]-c的数。
这样，从s[l]到s[r-1]都是等于s[i]-c的数字，则等于s[i]-c的数字个数有r-l个，累加进答案中。
s[i]-c是越来越大的，所以l和r都会越来越往右。

## 1.2 逛画展
## 题目描述
博览馆正在展出由世上最佳的 $m$ 位画家所画的图画。
游客在购买门票时必须说明两个数字，$a$ 和 $b$，代表他要看展览中的第 $a$ 幅至第 $b$ 幅画（包含 $a,b$）之间的所有图画，而门票的价钱就是一张图画一元。
Sept 希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。
请求出他购买门票时应选择的 $a,b$，数据保证一定有解。
若存在多组解，**输出 $a$ 最小的那组**。
## 输入格式
第一行两个整数 $n,m$，分别表示博览馆内的图画总数及这些图画是由多少位名师的画所绘画的。
第二行包含 $n$ 个整数 $a_i$，代表画第 $i$ 幅画的名师的编号。
## 输出格式
一行两个整数 $a,b$。
## 输入输出样例 #1
### 输入 #1
```
12 5
2 5 3 1 3 2 4 1 1 5 4 3
```
### 输出 #1
```
2 7
```
## 说明/提示
#### 数据规模与约定
- 对于 $30\%$ 的数据，有 $n\le200$，$m\le20$。
- 对于 $60\%$ 的数据，有 $n\le10^5$，$m\le10^3$。
- 对于 $100\%$ 的数据，有 $1\leq n\le10^6$，$1 \leq a_i \leq m\le2\times10^3$。

```cpp
#include<iostream>
using namespace std;
#define MAXN 1000010
int n, m, l,r, sum[2005], a[MAXN];
int ans, ansl, ansr, num;
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	l = 1;
	r = 1;
	num = 0;
	ans = MAXN;
	while (l <= r && r <= n + 1) {
		if (num < m) {
			r++;
			sum[a[r - 1]]++;
			if (sum[a[r - 1]] == 1)
				num++;
		}
		else {
			if (ans > r - l) {
				ans = r - l;
				ansl = l;
				ansr = r - 1;
			}
			sum[a[l]]--;
			if (sum[a[l]] == 0)
				num--;
			l++;
		}
	}
	cout << ansl << " " << ansr;
	return 0;
}
```
分析：
由于需要得到一个区间的两个端点，这个区间出现的数字是1到m至少各出现一次，那么可以使用双指针法维护符合要求的区间。
根据个人习惯，左指针和右指针表示为左闭右开或左闭右闭。
这里使用左闭右开的方式，即[l,r)，即参观的画的作者为al,al+1,...,ar-1。
考虑贪心策略：当左指针固定时，将右指针向右延伸，直到区间内凑齐1到m的数字为止。可以使用数组sum来记录区间内每个画家的画的数量，用变量num记录区间内不同画家的人数。
如果区间内没有全部的画家，那么需要向右延伸，将新加入画家编号a[r-1]的数量，也就是sum[a[r-1]]++。如果原来的sum[a[r-1]]=0，说明这个画家的画是在区间里第一次看到，那么num增加到1.此时r-l就是区间的长度，打擂台记录最小值和区间端点位置。
如果可以看到画家的画，尝试去除区间最左侧的画，也就是sum[a[l]]--。如果sum[a[l]]=0，说明这个画家的画是最后一次看到，那么num减少到0。此时l++。如果去掉了这个画家的最后一幅画，num要减1.
然后尝试向右移动左指针，继续判断是否符合要求，还是需要继续将右指针往右移动获得更多的画。

让我们手动模拟代码执行过程，并在每一步列出 `sum` 数组（仅包含窗口内有值的部分）和 `num` 值。  
---
## **输入**
```
12 5
2 5 3 1 3 2 4 1 1 5 4 3
```
`n = 12`，`m = 5`（共 5 位画家）
---
## **模拟执行过程**
| 步骤 | `l` | `r` | `a[r]` | `sum` (仅显示非 0 值) | `num` | `窗口` | `最优区间 ansl, ansr` |
|----|----|----|----|----------------|----|------------|------------|
| 1  | 1  | 2  | 2  | `{2:1}`         | 1  | `[2]`       | -          |
| 2  | 1  | 3  | 5  | `{2:1, 5:1}`    | 2  | `[2,5]`     | -          |
| 3  | 1  | 4  | 3  | `{2:1, 5:1, 3:1}` | 3  | `[2,5,3]`   | -          |
| 4  | 1  | 5  | 1  | `{2:1, 5:1, 3:1, 1:1}` | 4  | `[2,5,3,1]` | -          |
| 5  | 1  | 6  | 3  | `{2:1, 5:1, 3:2, 1:1}` | 4  | `[2,5,3,1,3]` | -          |
| 6  | 1  | 7  | 2  | `{2:2, 5:1, 3:2, 1:1}` | 4  | `[2,5,3,1,3,2]` | -          |
| 7  | 1  | 8  | 4  | `{2:2, 5:1, 3:2, 1:1, 4:1}` | **5** | `[2,5,3,1,3,2,4]` | **`(2,7)`** |
| 8  | 2  | 8  | -  | `{2:1, 5:1, 3:2, 1:1, 4:1}` | 5  | `[5,3,1,3,2,4]` | **`(2,7)`** |
| 9  | 3  | 8  | -  | `{2:1, 5:0, 3:2, 1:1, 4:1}` | **4** | `[3,1,3,2,4]` | **`(2,7)`** |
| 10 | 3  | 9  | 1  | `{2:1, 3:2, 1:2, 4:1}` | 4  | `[3,1,3,2,4,1]` | **`(2,7)`** |
| 11 | 3  | 10 | 1  | `{2:1, 3:2, 1:3, 4:1}` | 4  | `[3,1,3,2,4,1,1]` | **`(2,7)`** |
| 12 | 3  | 11 | 5  | `{2:1, 3:2, 1:3, 4:1, 5:1}` | **5** | `[3,1,3,2,4,1,1,5]` | **`(3,7)`** |
| 13 | 4  | 11 | -  | `{2:1, 3:1, 1:3, 4:1, 5:1}` | **5** | `[1,3,2,4,1,1,5]` | **`(3,7)`** |
| 14 | 5  | 11 | -  | `{2:1, 3:1, 1:2, 4:1, 5:1}` | **5** | `[3,2,4,1,1,5]` | **`(3,7)`** |
| 15 | 6  | 11 | -  | `{2:1, 3:0, 1:2, 4:1, 5:1}` | **4** | `[2,4,1,1,5]` | **`(3,7)`** |

最终答案是 **`(2,7)`**。
---
## **结果**
```
2 7
```
---
## **解释**
- **第 7 步**：当 `r = 7` 时，窗口 `[2,5,3,1,3,2,4]` **刚好包含了所有 `m = 5` 位画家**，`num = 5`，此时最短区间是 **`(2,7)`**。
- **之后 `l` 右移**，寻找更短的窗口，但直到 `l = 3`，`r = 7` 才找到一个新窗口 `[3,1,3,2,4]`，仍然包含所有画家，但区间 **比 `(2,7)` 长**，因此最终答案仍然是 `(2,7)`。
---
## **总结**
- `sum[a[r]]++` 统计每个画家编号出现的次数
- `num` 记录当前窗口内 **独立** 画家的数量
- `l` 和 `r` 滑动维护窗口，`r` 扩展，`l` 收缩
- 计算最短包含所有画家的子区间，并返回 `ansl, ansr`

## 注：双指针是使用队列维护一个符合条件的区间，右指针增加相当于入队，左指针增加相当于出队。

# 1.3 最大子段和
## 题目描述
给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。
## 输入格式
第一行是一个整数，表示序列的长度 $n$。
第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。
## 输出格式
输出一行一个整数表示答案。
## 输入输出样例 #1
### 输入 #1
```
7
2 -4 3 -1 2 -4 3
```
### 输出 #1
```
4
```
## 说明/提示
#### 样例 1 解释
选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。
#### 数据规模与约定
- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

### 使用双指针法
```cpp
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int a[n];
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    int l = 0, r = 0, sum = 0, ans = -10000;

    while (r < n) {
        sum += a[r];  // 右指针扩展窗口
        ans = max(ans, sum);  // 更新最大值
        // 若 sum < 0，则丢弃当前窗口，左指针右移
        while (sum < 0 && l <= r) {
            sum -= a[l]; // 左指针收缩窗口
            l++;
        }
        r++; // 右指针继续扩展
    }
    cout << ans;
    return 0;
}
```

### 使用动态规划
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	int n,a,f=0,ans=-10000;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a;
		f=max(f+a,a);
		ans=max(f,ans);
	}
	cout<<ans;
}
```

# 二、空间换时间
# 1.4 直播获奖
## 题目描述
NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。
更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。
作为评测组的技术人员，请你帮 CCF 写一个直播程序。
## 输入格式
第一行有两个整数 $n, w$。分别代表选手总数与获奖率。  
第二行有 $n$ 个整数，依次代表逐一评出的选手成绩。
## 输出格式
只有一行，包含 $n$ 个非负整数，依次代表选手成绩逐一评出后，即时的获奖分数线。相邻两个整数间用一个空格分隔。
## 输入输出样例 #1
### 输入 #1
```
10 60
200 300 400 500 600 600 0 300 200 100
```
### 输出 #1
```
200 300 400 400 400 500 400 400 300 300
```
## 输入输出样例 #2
### 输入 #2
```
10 30
100 100 600 100 100 100 100 100 100 100
```
### 输出 #2
```
100 100 600 600 600 600 100 100 100 100
```
## 说明/提示
### 样例 1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)
---
### 数据规模与约定
各测试点的 $n$ 如下表：
| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |
对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。
---
### 提示
在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

```cpp
#include<iostream>
using namespace std;
int t[610],n,w;
int main(){
    int tmp;
    cin>>n>>w;
    for(int i=1;i<=n;i++){
        cin>>tmp;
        t[tmp]++;
        int sum=0;
        for(int j=600;j>=0;j--){
            sum+=t[j];
            if(sum>=max(1,i*w/100)){
                cout<<j<<" ";
                break;
            }
        }
    }
    return 0;
}
```
分析：每测评出一个人的成绩就将所有人排序一次，然后输出对应排名，一共有n个人，共排序n次。如果使用快速排序（或者是sort()等函数），时间复杂度是O($n^2logn$)，只能获得50分，如果使用插入排序，将新得到的分数插入到有序的分数数组中，时间复杂度是O($n^2$)，可以获得85分。
发现需要排序的数值不超过600，因此考虑其他的排序方法。使用计数排序，每次评出一个人的成绩，就加入对应的“桶”中，然后从高往低统计累加的人数，达到获奖人数时输出分数线。这种做法的时间复杂度是O(An)，其中A是指成绩的值域上限，可以通过全部测试点。

解决同一种问题有不同的算法，其算法复杂度和某些变量的大小有关，这时应当选择合适的算法使得效率最高，例如，对一个数列进行排序，如果这个数列的值域（假设是A）比较小而数量（假设有n个数）较多，可以使用时间复杂度O(n+A)的计数排序；如果值域很大而数量没那么多，则可以使用时间复杂度为O($nlogn$)的快速排序。

# 1.5 求和
## 题目背景
NOIP2015 普及组 T3
## 题目描述
一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。
| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **颜色和数字** | $\color{blue}{5}$ | $\color{blue}{5}$ | $\color{red}{3}$ | $\color{red}{2}$ | $\color{blue}{2}$ | $\color{red}{2}$ |
定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：
1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。
2. $color_x=color_z$。
满足上述条件的三元组的分数规定为 $(x+z) \times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可
## 输入格式
第一行是用一个空格隔开的两个正整数 $n$ 和 $m,n$ 表纸带上格子的个数，$m$ 表纸带上颜色的种类数。
第二行有 $n$ 用空格隔开的正整数，第 $i$ 个数字表示纸带上编号为 $i$ 格子上面写的数字 $number_i$。
第三行有 $n$ 用空格隔开的正整数，第 $i$ 数字表示纸带上编号为 $i$ 格子染的颜色 $color_i$。
## 输出格式
一个整数，表示所求的纸带分数除以 $10007$ 所得的余数。
## 输入输出样例 #1
### 输入 #1
```
6 2
5 5 3 2 2 2
2 2 1 1 2 1
```
### 输出 #1
```
82
```
## 输入输出样例 #2
### 输入 #2
```
15 4
5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
2 2 3 3 4 3 3 2 4 4 4 4 1 1 1
```
### 输出 #2
```
1388
```
## 说明/提示
**样例 1 解释**
纸带如题目描述中的图所示。
所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。
所以纸带的分数为 $(1 + 5) \times (5 + 2) + (4 + 6) \times (2 + 2) = 42 + 40 = 82$。
对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；
对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；
对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000$，且不存在出现次数超过 $ 20 $ 的颜色；
对于全部 $10$ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, 1 ≤ color_i ≤ m,1≤number_i≤100000$。

```cpp

```
分析：题目要求有几个三元组(x,y,z)符合要求，最简单的思路使用三重循环依次枚举x,y,z，然后验证是否符合要求。这样的时间复杂度是$O(n^3)$，效率很低，无法在规定时间内完成计算。

