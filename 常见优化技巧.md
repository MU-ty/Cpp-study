评价算法的标准，除了正确性以外，最重要的就是程序的运行效率是否足够高，是否可以在 限定的时间内处理完指定的数据。在“暴力枚举”一章中介绍了可以通过剔除无效操作来提升算 法效率。除此之外，还可以用“单调性”和“空间换时间”来优化时间复杂度。将这两种思想结 合，产生了单调栈和单调队列等工具。
这些技巧可以帮助我们排除无效选项，在一定范围内保持单调性，常常可以将一些问题求解 的时间复杂度降到O(n)，因此称为线性时间复杂度优化。
# 一、双指针法
## 1.1 A-B数对
## 题目背景
出题是一件痛苦的事情！
相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！
## 题目描述
给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。
## 输入格式
输入共两行。
第一行，两个正整数 $N,C$。
第二行，$N$ 个正整数，作为要求处理的那串数。
## 输出格式
一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。
## 输入输出样例 #1
### 输入 #1
```
4 1
1 1 2 3
```
### 输出 #1
```
3
```
## 说明/提示
对于 $75\%$ 的数据，$1 \leq N \leq 2000$。
对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

```
#include<bits/stdc++.h>
using namespace std;
#define MAXN 200010
int s[MAXN];
int main() {
	int n, c;
	cin >> n >> c;
	for (int i = 0; i < n; i++)
		cin >> s[i];
	sort(s, s + n);
	int l = 0, r = 0;
	long long sum = 0;
	for (int i = 0; i < n; i++) {
		while (s[l] < s[i] - c && l < n)
			l++;
		while (s[r] <= s[i] - c && r < n)
			r++;
		if (s[i] - s[l] == c) {
			sum += r - l;
		}
	}
	cout << sum << endl;
	return 0;
}
```
解释：对于s[i]，我们要找的是s[i]-c。
如果s[i]
